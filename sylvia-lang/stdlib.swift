//
//  stdlib.swift
//



func add(a: String, b: String) throws -> String { // TO DO: math funcs should use Scalars (union of Int|UInt|Double) (e.g. pinch Scalar struct from entoli) allowing native language to have a single unified `number` type (numeric values might themselves be represented in runtime as Text value annotated with scalar info for efficiency, or as distinct Number values that can be coerced to/from Text)
    return String(Int(a)! + Int(b)!)
}


let signature_add = ( // TO DO: how best to define signatures? (arguably these could be auto-generated given func signatures, as long as handlerEnv/bodyEnv/commandEnv are reserved parameter names, and a standard naming convention is used to identify exported funcs, e.g. `export_add`; note: one benefit to not having `export_` prefixes in function names is that partial compilation will produce nicer Swift code) // TBH, we really want to avoid signatures completely, and just autogenerate Handler_NAME classes directly; all this signature info can then be defined in native language's FFI (once that's bootstrapped via, say, Python-based code generation similar to that used in Swift development); note that even FFI could infer simple Coercion types from Swift func's signature, e.g. `String`->`asString` (it's only when additional constraints are applied - e.g. non-empty, min/max length -  that this info must be explicitly stated in FFI definition)
    name: "add",
    input: (a: asString, b: asString),
    output: asString,
    errors: true,
    env: EnvType.noEnv // TO DO: can/should this be >1 enum?
)
// TO DO: what about user documentation (e.g. should input.N and output be `(type: BridgingCoercion, description: String)`, or are documentation strings better kept separately? [partly depends on what sort of interactive runtime debugging we want to provide: if error on unpacking parameter, could be helpful to have that parameter's name+type+description])



// auto-generated code

class Handler_add_a_b: Value, Callable {
    
    // TO DO: if code-generating Handler classes directly from FFI definition then name, parameters, input/output coercions, etc should be defined here (Coercions should instantiate lazily)
    
    // auto-generated introspection vars
    var name: String { return signature_add.name }
    var parameters: [Parameter] { return [(name: "a", type: signature_add.input.0), (name: "b", type: signature_add.input.1)] }
    var result: Coercion { return signature_add.output }
    
    func call(command: Command, commandEnv: Env, handlerEnv: Env, type: Coercion) throws -> Value { // TO DO: is handlerEnv *always* module env? (bearing in mind that module envs need to be created as subenvs to runtime's root env)
        // TO DO: throw TooManyArgumentsException if `command.arguments.count > self.parameters.count`?
        do{
            let result = try add( // command's name is autogenerated
                // autogenerate code for adding command's arguments
                a: try signature_add.input.0.unbox(value: command.argument(0), env: commandEnv),
                b: try signature_add.input.1.unbox(value: command.argument(1), env: commandEnv)
                // autogenerate code for adding zero or more 'env' arguments
            )
            return try signature_add.output.box(value: result, env: handlerEnv)
        } catch {
            throw HandlerFailedException(handler: self, error: error)
        }
    }
}


func show(value: Value) {
    print(value)
}



class Handler_show_value: Value, Callable {
    
    let arg_0 = asAny
    
    let name: String = "show"
    private(set) lazy var parameters: [Parameter] = [(name: "value", type: arg_0)]
    let result: Coercion = asNothing

    func call(command: Command, commandEnv: Env, handlerEnv: Env, type: Coercion) throws -> Value {
        do{
            show(
                value: try arg_0.unbox(value: command.argument(0), env: commandEnv) // TO DO: these calls really need to be done in function that throws descriptive "HANDLER can't coerce parameter NAME to TYPE: ARG" errors
            )
            return noValue // autogenerate alternate code to return `nothing` instead of calling `box()`
        } catch {
            throw HandlerFailedException(handler: self, error: error)
        }
    }
}


// TO DO: auto-generated load func

func stdlib_load(env: Env) throws { // TO DO: this adds directly to supplied env rather than creating its own; who should be responsible for creating module namespaces? (and who is responsible for adding modules to a global namespace where scripts can access them); Q. what is naming convention for 3rd-party modules? (e.g. reverse domain), and how will those modules appear in namespace (e.g. flat/custom name or hierarchical names [e.g. `com.foo.module[.handler]`])
    try env.add(handler: Handler_add_a_b()) // TO DO: loading should never fail (unless there's a module implementation bug)
    try env.add(handler: Handler_show_value())
    
    try env.set("text", to: asText)
    try env.set("list", to: asList)
    try env.set("anything", to: asAny)
    
    try env.set("nothing", to: noValue)
}
